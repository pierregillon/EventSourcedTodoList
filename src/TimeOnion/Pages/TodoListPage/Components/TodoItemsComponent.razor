@using TimeOnion.Domain.Todo.Core
@using TimeOnion.Domain.Todo.UseCases
@using TimeOnion.Pages.TodayTaskPreparation
@using TimeOnion.Domain.Categories
@using TimeOnion.Domain.Categories.Core
@inherits BlazorState.BlazorStateComponent

@if (TodoListId is not null)
{
    <MudDropContainer
        @ref="_container"
        T="TodoListItemReadModel"
        Items="Items"
        ItemsSelector="@((item, dropzone) => true)"
        ItemDropped="info => info.Item is not null ? UpdateItem(info.Item.ListId, info.Item.Id, info.IndexInZone, info.DropzoneIdentifier) : Task.CompletedTask"
        ApplyDropClassesOnDragStarted="true"
        >
        <ChildContent>
            @foreach (var category in Categories)
            {
                <MudDropZone
                    T="TodoListItemReadModel"
                    Identifier="@category.Id.Value.ToString()"
                    AllowReorder="true"
                    ItemIsDisabled="model => true"
                    ItemsSelector="model => model.CategoryId == category.Id"
                    DraggingClass="category-dragging"
                    CanDropClass="category-dragging"
                    ItemDraggingClass="in-category-dragging"
                    >
                    <div class="d-flex gap-1 align-center" style="margin-left: 22px">
                        <MudIcon
                            Icon="@Icons.Material.Outlined.Folder"
                            Color="Color.Secondary"
                            Size="Size.Large">
                        </MudIcon>
                        <TextEditor
                            Text="@category.Name"
                            TextChanged="text => RenameCategory(category.Id, text, TodoListId)">
                        </TextEditor>
                    </div>
                </MudDropZone>
            }

            <MudDropZone
                T="TodoListItemReadModel"
                Identifier=""
                AllowReorder="true"
                ItemIsDisabled="model => true"
                ItemsSelector="model => model.CategoryId is null"
                DraggingClass="no-category-dragging"
                />

        </ChildContent>
        <ItemRenderer>
            <TodoItemComponent Item="@context"></TodoItemComponent>
        </ItemRenderer>
    </MudDropContainer>

    <div class="d-flex">
        <MudCheckBox
            Class="compact fake"
            Checked="@(false)"
            Color="Color.Secondary">
        </MudCheckBox>

        <MudTextField
            T="string"
            InputMode="InputMode.text"
            Text="@State.NewTodoItemDescription"
            TextChanged="itemDescription => AddItemToDo(TodoListId, itemDescription)"
            TextUpdateSuppression="false"
            Class="compact"
            DisableUnderLine="true">
        </MudTextField>
    </div>
}

<style>
     .mud-drop-item-preview-start{
        /*top: -20px;*/
        position: relative;
        height: 2px;
     }
     
     .category-dragging {
        border: 1px dashed red;
        border-radius: 5px;
     }
     
     .no-category-dragging {
        border: 1px dashed lightgray;
        border-radius: 5px;
     }
     
     .in-category-dragging {
        border-color: red !important;
        color: red;
     }
</style>

@code {

    [Parameter]
    public TodoListId? TodoListId { get; set; }

    TodoListState State => GetState<TodoListState>();
    IReadOnlyCollection<TodoListItemReadModel> Items => State.TodoListItems[TodoListId];
    IReadOnlyCollection<CategoryReadModel> Categories => State.Categories[TodoListId];

    private MudDropContainer<TodoListItemReadModel>? _container;

    protected override async Task OnInitializedAsync()
    {
        if (TodoListId is null)
        {
            return;
        }
        await Mediator.Send(new TodoListState.LoadCategories(TodoListId));
        await Mediator.Send(new TodoListState.LoadTodoListItems(TodoListId));
        await base.OnInitializedAsync();
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        await base.SetParametersAsync(parameters);

        if (parameters.TryGetValue<TodoListId?>(nameof(TodoListId), out _))
        {
            _container?.Refresh();
        }
    }

    private async Task AddItemToDo(TodoListId listId, string itemDescription)
        => await Mediator.Send(new TodoListState.AddNewItem(listId, itemDescription));

    private async Task UpdateItem(TodoListId listId, TodoItemId itemId, int indexInCategory, string targetCategoryIdString)
    {
        var todoListItems = Items.ToList();
        var currentItem = todoListItems.First(x => x.Id == itemId);

        await UpdateItemCategory(listId, itemId, targetCategoryIdString, currentItem);
        await UpdateItemPosition(listId, itemId, indexInCategory, todoListItems, currentItem);
    }

    private async Task UpdateItemCategory(
        TodoListId listId,
        TodoItemId itemId,
        string targetCategoryIdString,
        TodoListItemReadModel currentItem
        )
    {
        if (!string.IsNullOrWhiteSpace(targetCategoryIdString))
        {
            var targetIdCategory = CategoryId.From(targetCategoryIdString);

            if (currentItem.CategoryId != targetIdCategory)
            {
                await Mediator.Send(new TodoListState.CategorizeItem(listId, itemId, targetIdCategory));
            }
        }
        else
        {
            if (currentItem.CategoryId is not null)
            {
                await Mediator.Send(new TodoListState.DecategorizeItem(listId, itemId));
            }
        }
    }

    private async Task UpdateItemPosition(
        TodoListId listId,
        TodoItemId itemId,
        int indexInCategory,
        List<TodoListItemReadModel> todoListItems,
        TodoListItemReadModel currentItem
        )
    {
        var currentItemIndex = todoListItems.IndexOf(currentItem);

        if (currentItemIndex < indexInCategory)
        {
            indexInCategory++;
        }

        var referenceItem = Items.Where((_, i) => i == indexInCategory).FirstOrDefault();
        if (referenceItem is not null && referenceItem.Id != itemId)
        {
            await Mediator.Send(new TodoListState.RepositionItemAboveAnother(listId, itemId, referenceItem.Id));
        }
        else if (referenceItem is null)
        {
            await Mediator.Send(new TodoListState.RepositionItemAtTheEnd(listId, itemId));
        }
    }

    private async Task Delete(TodoListId listId)
        => await Mediator.Send(new TodoListState.DeleteTodoList(listId));

    private async Task RenameCategory(CategoryId categoryId, string newName, TodoListId listId)
        => await Mediator.Send(new TodoListState.RenameCategory(categoryId, newName, listId));

}
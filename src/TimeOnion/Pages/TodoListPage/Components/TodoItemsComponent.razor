@using TimeOnion.Domain.Todo.Core
@using TimeOnion.Domain.Todo.UseCases
@using TimeOnion.Domain.Categories
@using TimeOnion.Domain.Categories.Core
@using BlazorState
@inherits BlazorStateComponent

<div>
    @if (TodoListId is not null)
    {
        <MudDropContainer
            @ref="_container"
            T="TodoListItemReadModel"
            Items="Items"
            ItemsSelector="@((item, dropzone) => true)"
            ItemDropped="info => info.Item is not null ? UpdateItem(info.Item.ListId, info.Item.Id, info.IndexInZone, info.DropzoneIdentifier) : Task.CompletedTask">
            <ChildContent>
                @foreach (var category in Categories)
                {
                    <MudDropZone
                        T="TodoListItemReadModel"
                        Identifier="@category.Id.Value.ToString()"
                        Style="transition: none"
                        Class="category"
                        AllowReorder="true"
                        ItemIsDisabled="_ => true"
                        ItemsSelector="model => model.CategoryId == category.Id"
                        CanDropClass="border-2 border-dashed mud-border-lines-default mud-border-secondary">

                        <CategoryComponent Category="@category"></CategoryComponent>

                    </MudDropZone>
                }

                <MudDropZone
                    T="TodoListItemReadModel"
                    Identifier=""
                    AllowReorder="true"
                    ItemIsDisabled="_ => true"
                    ItemsSelector="model => model.CategoryId is null"/>

            </ChildContent>
            <ItemRenderer>
                <TodoItemComponent Item="@context"></TodoItemComponent>
            </ItemRenderer>
        </MudDropContainer>

        <div class="d-flex gap-1">

            <MudMenu
                Class="invisible d-none d-md-flex"
                Icon="@Icons.Material.Filled.MoreHoriz"
                Size="Size.Small">
            </MudMenu>

            <MudIconButton
                Icon="@Icons.Material.Filled.Add"
                Size="Size.Small"
                Color="Color.Primary"
                OnClick="_ => Dispatch(new TodoListState.InsertNewItemToDo(TodoListId, TodoItemId.None))">
            </MudIconButton>
        </div>
    }
</div>

@inject IJSRuntime JavascriptRuntime;

@code {

    [Parameter]
    public TodoListId? TodoListId { get; set; }

    TodoListState State => GetState<TodoListState>();

    IReadOnlyCollection<TodoListItemReadModel> Items => State.TodoListDetails.Get(TodoListId!).TodoListItems;

    IReadOnlyCollection<CategoryReadModel> Categories => State.TodoListDetails.Get(TodoListId!).Categories;

    private MudDropContainer<TodoListItemReadModel>? _container;

    protected override async Task OnInitializedAsync()
    {
        if (TodoListId is null)
        {
            return;
        }
        await Mediator.Send(new TodoListState.LoadCategories(TodoListId));
        await Mediator.Send(new TodoListState.LoadTodoListItems(TodoListId));
        
        await base.OnInitializedAsync();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (!firstRender)
        {
            await JavascriptRuntime.InvokeAsync<string>("enableTouchOnMudDropItems", Array.Empty<object?>());
        }
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        if (parameters.TryGetValue<TodoListId?>(nameof(TodoListId), out var newId))
        {
            if (newId is not null && newId != TodoListId)
            {
                await Mediator.Send(new TodoListState.LoadCategories(newId));
                await Mediator.Send(new TodoListState.LoadTodoListItems(newId));
            }

            await base.SetParametersAsync(parameters);

            _container?.Refresh();
        }
        else
        {
            await base.SetParametersAsync(parameters);
        }
    }

    private async Task Dispatch(IAction action) => await Mediator.Send(action);

    private async Task UpdateItem(TodoListId listId, TodoItemId itemId, int indexInCategory, string targetCategoryIdString)
    {
        var targetIdCategory = !string.IsNullOrWhiteSpace(targetCategoryIdString)
            ? CategoryId.From(targetCategoryIdString)
            : null;

        await UpdateItemCategory(listId, itemId, targetIdCategory);
        await UpdateItemPosition(listId, itemId, indexInCategory, targetIdCategory);
    }

    private async Task UpdateItemCategory(TodoListId listId, TodoItemId itemId, CategoryId? targetIdCategory)
    {
        var currentItem = Items.ToList().First(x => x.Id == itemId);

        if (targetIdCategory is not null)
        {
            if (currentItem.CategoryId != targetIdCategory)
            {
                await Mediator.Send(new TodoListState.CategorizeItem(listId, itemId, targetIdCategory));
            }
        }
        else if (currentItem.CategoryId is not null)
        {
            await Mediator.Send(new TodoListState.DecategorizeItem(listId, itemId));
        }
    }

    private async Task UpdateItemPosition(TodoListId listId, TodoItemId itemId, int indexInCategory, CategoryId? targetIdCategory)
    {
        var currentItem = Items.First(x => x.Id == itemId);
        var itemsInSameCategory = Items
            .Where(x => x.CategoryId == targetIdCategory)
            .ToList();

        var currentItemIndex = itemsInSameCategory.IndexOf(currentItem);
        if (currentItemIndex < indexInCategory)
        {
            indexInCategory++;
        }

        var referenceItem = itemsInSameCategory.Where((_, i) => i == indexInCategory).FirstOrDefault();
        if (referenceItem is not null && referenceItem.Id != itemId)
        {
            await Mediator.Send(new TodoListState.RepositionItemAboveAnother(listId, itemId, referenceItem.Id));
        }
        else if (referenceItem is null)
        {
            await Mediator.Send(new TodoListState.RepositionItemAtTheEnd(listId, itemId));
        }
    }

}